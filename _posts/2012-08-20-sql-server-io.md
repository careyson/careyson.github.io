---
layout: post
title: "硬盘的原理以及SQL Server如何利用硬盘原理减少IO"
date: 2012-08-20
categories: blog
tags: [博客园迁移]
---

### 简介

硬盘作为现在计算机内部最后的机械存储部件，速度相比较内存和Cache而言会慢好几个数量级。但所幸的是，硬盘的成本是远远低于内存的。因此硬盘作为永久存储器是比较合适的，所幸的是为了克服硬盘慢速带来的问题，操作系统会对硬盘的使用有一个优化，下面让我们先来看硬盘的原理。

### 硬盘的原理简介

一个典型的硬盘如图1所示。

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2012-08-20-sql-server-io/sql-server-io-201208200900297128.jpg)](http://images.cnblogs.com/cnblogs_com/CareySon/201208/20120820090028225.jpg)

图1.一个典型的硬盘

由图1可以看到，硬盘上磁盘进行高速旋转，磁头臂在磁盘上来回移动进行数据的读取和写入。这也是为什么我们说硬盘是一个机械部件的原因。通过图2我们可以更抽象的来看磁盘读取数据的方式。磁盘由圆心向外被划分为多个磁道，所谓摆臂在磁道上来回移动也就是摆臂在磁道间的来回移动，

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2012-08-20-sql-server-io/sql-server-io-201208200900305077.jpg)](http://images.cnblogs.com/cnblogs_com/CareySon/201208/201208200900292078.jpg)

图2.更抽象的硬盘原理

除了磁道之外，一个磁道还会被划分为多个扇区，如图3所示。

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2012-08-20-sql-server-io/sql-server-io-201208200900316373.jpg)](http://images.cnblogs.com/cnblogs_com/CareySon/201208/201208200900303931.jpg)

图3.磁道，扇区和簇

我们可以看到，扇区是硬盘寻址的最小单位，但实际上分配空间时最小的单位是簇\(Clusters\)。这也就是为什么硬盘上文件的实际大小和占用空间不同的原因。

### 磁盘读写数据所花费的时间

在了解了硬盘的基本原理之后，不难推算出，磁盘上数据读取和写入所花费的时间可以分为三个部分。

**1.寻道时间**

所谓寻道时间，其实就是磁臂移动到指定磁道所需要的时间，这部分时间又可以分为两部分：

寻道时间=启动磁臂的时间+常数\*所需移动的磁道数

其中常数和驱动器的的硬件相关，启动磁臂的时间也和驱动器的硬件相关

**2.旋转延迟**

旋转延迟指的是把扇区移动到磁头下面的时间。这个时间和驱动器的转数有关，我们通常所说的7200转的硬盘的转就是这个。

平均旋转延迟=1/\(2\*转数每秒\)

比如7200转的硬盘的平均旋转延迟等于1/2\*120≈4.17ms

旋转延迟只和硬件有关。

3.传输时间

传输时间指的是从磁盘读出或将数据写入磁盘的时间。

这个时间等于：所需要读写的字节数/每秒转速\*每扇区的字节数

### 磁盘调度算法

通过上面硬盘读写数据所分的三部分时间不难看出，大部分参数是和硬件相关的，操作系统无力优化。只有所需移动的磁道数是可以通过操作系统来进行控制的，所以减少所需移动的磁道数是减少整个硬盘的读写时间的唯一办法。

因为操作系统内可能会有很多进程需要调用磁盘进行读写，因此合理的安排磁头的移动以减少寻道时间就是磁盘调度算法的目的所在，几种常见的磁盘调度算法如下。

**1.先来先服务算法\(FCFS\)**

这种算法将对磁盘的IO请求进行排队，按照先后顺序依次调度磁头。这种算法的特点是简单，合理，但没有减少寻道时间

**2.最短寻道时间算法\(SSFT\)**

这种算法优先执行所需读写的磁道离当前磁头最近的请求。这保证了平均寻道时间的最短，但缺点显而易见：离当前磁头比较远的寻道请求有可能一直得不到执行，这也就是所谓的“饥饿现象”。

**3.扫描算法\(SCAN\)**

这种算法在磁头的移动方向上选择离当前磁头所在磁道最近的请求作为下一次服务对象，这种改进有效避免了饥饿现象，并且减少了寻道时间。但缺点依然存在，那就是不利于最远一端的磁道访问请求。

**3.循环扫描算法\(CSCAN\)**

也就是俗称的电梯算法，这种算法是对最短寻道时间算法的改进。这种算法就像电梯一样，只能从1楼上到15楼，然后再从15楼下到1楼。这种算法的磁头调度也是如此,磁头只能从最里磁道到磁盘最外层磁道。然后再由最外层磁道移动到最里层磁道，磁头是单向移动的，在此基础上，才执行和最短寻道时间算法一样的，离当前磁头最近的寻道请求。这种算法改善了SCAN算法，消除了对两端磁道请求的不公平。

### 其它优化手段以及SQL Server是如何利用这些手段

除去上面通过磁盘调度算法来减少寻道时间之外。还有一些其它的手段同样可以利用，在开始之前，我首先想讲一下局部性原理。

**局部性原理**

所谓的局部性原理分为时间和空间上的。由于程序是顺序执行的，因此当前数据段附近的数据有可能在接下来的时间被访问到。这就是所谓的空间局部性。而程序中还存在着循环，因此当前被访问的数据有可能在短时间内被再次访问，这就是所谓的时间局部性原理。

因此在了解了局部性原理之后，我们可以通过以下几个手段来减少磁盘的IO。

**提前读\(Read-Ahead\)**

提前读也被称为预读。根据磁盘原理我们不难看出，在磁盘读取数据的过程中，真正读取数据的时间只占了很小一部分，而大部分时间花在了旋转延迟和寻道时间上，因此根据空间局部性原理，SQL Server每次读取数据的时间不仅仅读取所需要的数据，还将所请求数据附近的数据进行读取。这在SQL Server中被称为预读。SQL Server通过预读可以有效的减少IO请求。

**延迟写\(Delayed write\)**

同样，根据时间局部性原理，最近被访问的数据有可能再次被访问，因此当数据更改之后不马上写回磁盘，而是继续放在内存中，以备接下来的请求读取或者修改，是减少磁盘IO的另一个有效手段，在SQL Server中，实现延迟写是buffer pool,当一个修改请求被commit之后，并不会立刻写回磁盘，而是将修改的页标记为“脏”，然后根据某种机制通过checkpoint或lazy writer写回磁盘，关于checkpoint和lazy writer的原理，可以参考我之前的文章：[浅谈SQL Server中的事务日志\(二\)----事务日志在修改数据时的角色](http://www.cnblogs.com/CareySon/archive/2012/02/14/2351149.html).

**优化物理分布**

根据磁盘原理不难看出，如果所请求的数据在磁盘物理磁道之间是连续的，那么会减少磁头的移动距离，从而减少了寻道时间。因此相关的数据放在连续的物理空间上会减少寻道时间。SQL Server中，通过聚集索引使得数据根据主键在物理磁盘上连续，从而减少了寻道时间。

### 总结

本文谈了硬盘的原理，读写数据所花费的时间以及如何减少读写数据所花的时间，并且简单概述了SQL Server是如何利用这些特性减少IO的占用。理解磁盘的原理是进行性能调优的基础之一。

本文PDF版本可以[点击这里](https://files.cnblogs.com/CareySon/%E7%A1%AC%E7%9B%98%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8ASQLServer%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E7%A1%AC%E7%9B%98%E5%8E%9F%E7%90%86%E5%87%8F%E5%B0%91IO.rar)下载。
