---
layout: post
title: "【译】使用Ninject进行简单依赖注入"
date: 2009-12-13
categories: blog
tags: [博客园迁移]
---

那些最好的程序能够容纳不断变化的需求，当然，要求程序满足所有需求却难如登天。这就是该依赖注入发挥作用的时候了.依赖注入的最终目的是达到松耦合，而松耦合可以让程序在不重新编译的情况下通过配置程序来改变程序的某些部分。下面通过一个Demo来展现Ninject

我们创建一个**汽车模拟器程序** ,所有的汽车都需要燃料,而燃料的种类却多种多样,我们需要告诉这个模拟器使用何种燃料，让我们来做第一次尝试:

> 
>     // Unleaded.cs 
>     public class Unleaded {     
>     public void Burn() {         
>     Console.WriteLine("Unleaded fuel burning");    
>     } 
>     } 
>      
>     // Diesel.cs 
>     public class Diesel { 
>         public void Burn() { 
>            Console.WriteLine("Diesel fuel burning");     
>     	} 
>     } 
>      
>     // Car.cs 
>     public class Car { 
>         private Diesel fuel { get; set; }     
>     public Car() { 
>             fuel = new Diesel(); 
>                 
>     }  
>          
>     public void Start() { 
>             Console.WriteLine("Starting car");         
>     				fuel.Burn();     
>     } 
>     }  
>     // Driver.cs 
>     public class Driver {     
>     public Driver() {         
>     var car = new Car();         
>     car.Start();     
>     } 
>     }

这满足了最开始的要求，但是如果我们需要使用其它品种的燃料呢？我们不得不为此改变Car对象里的代码，这种做法是紧耦合的。因此，可是使用更好的方式，因为每一种燃料都是通过燃烧来产生热量，所以可以将其重构为接口：

> 
>     // IFuel.cs
>     public interface IFuel {
>         void Burn();
>     }

接下来，所有的燃料类型都继承IFuel接口

> 
>     public class Unleaded : IFuel { ... }
>     
>     public class Diesel : IFuel { ... }

因此，可以将Car的燃料属性改为IFuel

> 
>     private IFuel fuel { get; set; }

通过这种方式依然有问题，因为车仍然需要在指定使用何种燃料，这种方式在[ASP.NET MVC 2 Part – Creating Data Repositories](http://poweredbyalt.net/?p=197)里我进行了简短的讨论，称之为构造器注入，因为指定使用何种属性是通过构造器来完成的。

我们通过将Car的构造器进行改变，接受IFuel类型的参数并赋值给燃料属性来完成:

> 
>     public Car(IFuel _fuel) {
>         fuel = _fuel;
>     }

这是我们就需要在Driver初始化类中初始化Car实例来指定相应对象

> 
>     public Driver() {
>         var car = new Car(new Diesel());
>         car.Start();
>     }

虽然我们通过这种方式貌似降低了耦合，但是Driver对象仍然需要在代码中知道使用何种燃料。而我们希望达到的效果是在程序外部来指定。

使用Ninject,Ninject是.net依赖注入库中的一种，首先通过引用Ninject.Core.dll来进行引入，并在Car.cs中using Ninject.Core.

任何我们想实现依赖注入的地方我们都的赋予\[Inject\]标签,在此，对燃料加上这个标签：

> 
>     [Inject]
>     private IFuel fuel { get; set; }

下面一步是进行配置这部重头戏，配置信息会被包含在Ninject.Core.StartardModule的派生类当中，在此我们通过继承这个类并重写Load方法来实现依赖信息的设置:

> 
>     using Ninject.Core;
>     ...
>     public class FuelModule : StandardModule {
>         public override void Load() {
>             Bind<IFuel>().To<Diesel>();
>         }
>     }

Load方法中使用了Ninject的fluent接口中的方法来告诉程序中IFuel接口的类型是柴油（Diesel）

接下来我们还需要创建Ninject管理的一个类型，在这里我们使用”Kernel”,这个类型的构造函数接受一个包含注入信息的Module\(一般是从从StandardModule派生而来\)，在这里是FuelModule,然后我们”kernel”会给予我们相应的类型:

> 
>     public Driver4() {
>         var kernel = new StandardKernel(new FuelModule());
>         var car = kernel.Get<Car>();
>         car.Start();
>     }

在此，当需要改变燃料时，仅需要改变FuelModule就可以.

上面的方法还可以用于改变数据库仓储的类型，比如在测试的时候我们可以换掉数据库而通过连接一个虚拟的数据从而使测试更加轻松愉快:-\)

\------------------------------------------------------------------------------

原文链接:<http://poweredbyalt.net/?p=219>
