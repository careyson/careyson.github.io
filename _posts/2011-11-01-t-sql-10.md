---
layout: post
title: "T-SQL查询进阶-10分钟理解游标"
date: 2011-11-01
categories: blog
tags: [博客园迁移]
---

### **概述**

游标是邪恶的！

在关系数据库中，我们对于查询的思考是面向集合的。而游标打破了这一规则，游标使得我们思考方式变为逐行进行.对于类C的开发人员来着，这样的思考方式会更加舒服。

正常面向集合的思维方式是:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2011-11-01-t-sql-10/t-sql-10-201111011411225075.png)](http://images.cnblogs.com/cnblogs_com/CareySon/201111/201111011411205240.png)

而对于游标来说:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2011-11-01-t-sql-10/t-sql-10-201111011411256630.png)](http://images.cnblogs.com/cnblogs_com/CareySon/201111/201111011411247352.png)

这也是为什么游标是邪恶的，它会使开发人员变懒，懒得去想用面向集合的查询方式实现某些功能.

同样的，在性能上，游标会吃更多的内存，减少可用的并发，占用宽带，锁定资源，当然还有更多的代码量……

从游标对数据库的读取方式来说，不难看出游标为什么占用更多的资源，打个比方:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2011-11-01-t-sql-10/t-sql-10-201111011411286856.jpg)](http://images.cnblogs.com/cnblogs_com/CareySon/201111/201111011411278973.jpg)

当你从ATM取钱的时候，是一次取1000效率更高呢，还是取10次100？

### **既然游标这么“邪恶”，为什么还要学习游标**

我个人认为存在既是合理.归结来说，学习游标原因我归纳为以下2点

1.现存系统有一些游标，我们查询必须通过游标来实现

2.作为一个备用方式，当我们穷尽了while循环,子查询，临时表，表变量,自建函数或其他方式扔来无法实现某些查询的时候，使用游标实现.

### **T-SQL中游标的生命周期以及实现**

在T-SQL中，游标的生命周期由5部分组成

#### **1.定义一个游标**

在T-SQL中，定义一个游标可以是非常简单，也可以相对复杂，取决于游标的参数.而游标的参数设置取决于你对游标原理的了解程度.

游标其实可以理解成一个定义在特定**数据集** 上的指针，我们可以控制这个指针遍历**数据集** ，或者仅仅是指向特定的行，所以游标是定义在以Select开始的数据集上的:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2011-11-01-t-sql-10/t-sql-10-201111011411328445.png)](http://images.cnblogs.com/cnblogs_com/CareySon/201111/20111101141130562.png)

T-SQL中的游标定义在MSDN中如下:
    
    
    [DECLARE](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=DECLARE&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) cursor_name [CURSOR](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=CURSOR&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [ [LOCAL](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=LOCAL&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) | [GLOBAL](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=GLOBAL&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) ] 
         [ FORWARD_ONLY | [SCROLL](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=SCROLL&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) ] 
         [ STATIC | KEYSET | DYNAMIC | FAST_FORWARD ] 
         [ READ_ONLY | SCROLL_LOCKS | OPTIMISTIC ] 
         [ TYPE_WARNING ] 
         [FOR](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=FOR&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) select_statement 
         [ [FOR](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=FOR&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [UPDATE](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=UPDATE&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [ [OF](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=OF&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) column_name [ ,...n ] ] ]
    [;]

看起来很让人头痛是吧.下面仔细讲一下如何定义游标:

游标分为游标类型和游标变量，对于游标变量来说，遵循T-SQL变量的定义方法（啥，不知道T-SQL变量定义的规则？参考我前面的博文）.游标变量支持两种方式赋值，定义时赋值和先定义后赋值，定义游标变量像定义其他局部变量一样，在游标前加”@”,注意，如果定义全局的游标，只支持定义时直接赋值，并且不能在游标名称前面加“@”，两种定义方式如下:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2011-11-01-t-sql-10/t-sql-10-201111011411341279.png)](http://images.cnblogs.com/cnblogs_com/CareySon/201111/201111011411333886.png)

下面我们来看游标定义的参数:

**LOCAL和GLOBAL二选一**

**** LOCAL意味着游标的生存周期只在批处理或函数或存储过程中可见，而GLOBAL意味着游标对于特定**连接** 作为上下文，全局内有效,例如:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2011-11-01-t-sql-10/t-sql-10-201111011411376521.png)](http://images.cnblogs.com/cnblogs_com/CareySon/201111/201111011411356130.png)

如果不指定游标作用域，默认作用域为GLOBAL

**FORWARD\_ONLY 和 SCROLL 二选一**

**** FORWARD\_ONLY意味着游标只能从数据集开始向数据集结束的方向读取，FETCH NEXT是唯一的选项，而SCROLL支持游标在定义的数据集中向任何方向，或任何位置移动，如下图:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2011-11-01-t-sql-10/t-sql-10-201111011411405045.png)](http://images.cnblogs.com/cnblogs_com/CareySon/201111/201111011411393258.png)

**STATIC KEYSET DYNAMIC 和 FAST\_FORWARD 四选一**

这四个关键字是游标所在数据集所反应的表内数据和游标读取出的数据的关系

STATIC意味着，当游标被建立时，将会创建FOR后面的SELECT语句所包含数据集的副本存入tempdb数据库中，任何对于底层表内数据的更改不会影响到游标的内容.

DYNAMIC是和STATIC完全相反的选项,当底层数据库更改时，游标的内容也随之得到反映，在下一次fetch中，数据内容会随之改变

KEYSET可以理解为介于STATIC和DYNAMIC的折中方案。将游标所在结果集的唯一能确定每一行的主键存入tempdb,当结果集中任何行改变或者删除时，@@FETCH\_STATUS会为-2,KEYSET无法探测新加入的数据

FAST\_FORWARD可以理解成FORWARD\_ONLY的优化版本.FORWARD\_ONLY执行的是静态计划，而FAST\_FORWARD是根据情况进行选择采用动态计划还是静态计划，大多数情况下FAST\_FORWARD要比FORWARD\_ONLY性能略好.

**READ\_ONLY SCROLL\_LOCKS OPTIMISTIC 三选一  
** READ\_ONLY意味着声明的游标只能读取数据,游标不能做任何更新操作

SCROLL\_LOCKS是另一种极端，将读入游标的所有数据进行锁定，防止其他程序进行更改，以确保更新的绝对成功

OPTIMISTIC是相对比较好的一个选择，OPTIMISTIC不锁定任何数据，当需要在游标中更新数据时,如果底层表数据更新，则游标内数据更新不成功，如果，底层表数据未更新，则游标内表数据可以更新

#### **2.打开游标**

当定义完游标后，游标需要打开后使用，只有简单一行代码:
    
    
    [OPEN](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=OPEN&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) test_Cursor

注意，当全局游标和局部游标变量重名时，默认会打开局部变量游标

#### **3.使用游标**

游标的使用分为两部分,一部分是操作游标在数据集内的指向，另一部分是将游标所指向的行的部分或全部内容进行操作

只有支持6种移动选项,分别为到第一行（FIRST\),最后一行\(LAST\),下一行\(NEXT\),上一行\(PRIOR\),直接跳到某行\(ABSOLUTE\(n\)\),相对于目前跳几行\(RELATIVE\(n\)\),例如:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2011-11-01-t-sql-10/t-sql-10-201111011411445762.png)](http://images.cnblogs.com/cnblogs_com/CareySon/201111/201111011411425371.png)

对于未指定SCROLL选项的游标来说，只支持NEXT取值.

第一步操作完成后，就通过INTO关键字将这行的值传入局部变量:

比如下面代码:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2011-11-01-t-sql-10/t-sql-10-201111011411467483.png)](http://images.cnblogs.com/cnblogs_com/CareySon/201111/201111011411459010.png)

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2011-11-01-t-sql-10/t-sql-10-201111011411487808.png)](http://images.cnblogs.com/cnblogs_com/CareySon/201111/201111011411474875.png)

游标经常会和全局变量@@FETCH\_STATUS与WHILE循环来共同使用,以达到遍历游标所在数据集的目的,例如：

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2011-11-01-t-sql-10/t-sql-10-201111011411514413.png)](http://images.cnblogs.com/cnblogs_com/CareySon/201111/201111011411505973.png)

#### **4.关闭游标**

在游标使用完之后，一定要记得关闭,只需要一行代码:CLOSE+游标名称
    
    
    [CLOSE](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=CLOSE&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) test_Cursor

#### **5.释放游标**

当游标不再需要被使用后，释放游标，只需要一行代码:DEALLOCATE+游标名称
    
    
    [DEALLOCATE](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=DEALLOCATE&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) test_Cursor

### **对于游标一些优化建议**

  * 如果能不用游标，尽量不要使用游标
  * 用完用完之后一定要关闭和释放
  * 尽量不要在大量数据上定义游标
  * 尽量不要使用游标上更新数据
  * 尽量不要使用insensitive, static和keyset这些参数定义游标
  * 如果可以，尽量使用FAST\_FORWARD关键字定义游标
  * 如果只对数据进行读取，当读取时只用到FETCH NEXT选项，则最好使用FORWARD\_ONLY参数



### **总结**

本文从游标的基本概念，到生命周期来谈游标。游标是非常**邪恶** 的一种存在，使用游标经常会比使用面向集合的方法慢2-3倍，当游标定义在大数据量时，这个比例还会增加。如果可能，尽量使用while,子查询，临时表，函数，表变量等来替代游标，记住，游标永远只是你最后无奈之下的选择，而不是首选。

**游标是邪恶的！**
