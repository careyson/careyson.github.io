---
layout: post
title: "【译】SQL Server误区30日谈-Day8-有关对索引进行在线操作的误区"
date: 2012-10-25
categories: blog
tags: [博客园迁移]
---

本系列文章是我在sqlskill.com的PAUL的博客看到的，很多误区都比较具有典型性和代表性，原文来自[T-SQL Tuesday \#11: Misconceptions about.... EVERYTHING\!\!](http://www.sqlskills.com/blogs/paul/post/T-SQL-Tuesday-11-Misconceptions-about-EVERYTHING!!.aspx),经过我们团队的翻译和整理发布在[AgileSharp](http://www.agilesharp.com/)上。希望对大家有所帮助。

**误区 \#8: 在线索引操作不会使得相关的索引加锁**

_错误！_

__

__

__ 在线索引操作并不是想象的那么美好。

在线索引操作会在操作开始时和操作结束时对资源上短暂的锁。这有可能导致严重的阻塞问题。

在线索引操作开始时,会在被整理的资源上加一个共享的表锁,这个表锁在会在新的索引创建时、老索引进行版本扫描时一直持续。

但问题是，这个S锁会和表上的其它锁排成锁队列。这也就是意味着和S锁不兼容的其它锁在表上存在S锁或是表上的锁队列存在中包含S锁时，这类和S锁不兼容的锁操作也需要等待。这也意味着各种更新操作会被阻塞。同样，如果表上存在X锁或是IX锁时，S锁请求也会被阻塞。

上述步骤完成后，S锁会被去掉，但你可以发现这已经对数据更新产生了影响。这期间还会造成所有等待的更新操作的执行计划被重新编译

在线索引整理在开始需要加锁的部分完成后，剩下的大部分时间是不需要任何锁的。（这个大部分指的是整个在线索引整理的大部分时间）

当在线索引操作完成后，新建立的索引和老的索引上面都需要加一个构架修改锁（SCH\_M锁）来完成最终操作。这个锁可以想象成一个更强的表级排它锁。这个锁存在期间不允许对表做任何操作，针对表的执行计划也不能重编译。

在线索引操作最终阶段的阻塞问题和在线索引操作开始时由S锁造成的阻塞问题非常类似-在SCH\_M锁持续或者等待被授予期间，不允许对表进行任何操作。反之，表中存在任何读写操作时，SCH\_M锁也不能被授予。

在最终阶段的SCH\_M锁持续期间，旧的索引会被执行延迟DROP操作，元数据所指向的分配结构指向新的索引（所以index id不变）,表的版本被更新，恭喜，现在开始你已经拥有了一个全新的索引。

如你所见，在线索引操作的开始和结束阶段潜在存在着巨大的阻塞问题。所以技术上对在线索引操作应该称为“大部分时间在线索引操作”，但这种叫法可不会受到市场的欢迎。如果你想对在线索引操作了解更多，请阅读白皮书:Online Indexing Operations in SQL Server 2005。

译者注:汪洋有一篇关于在线索引操作非常详细的文章，有兴趣的同学可以阅读: [联机索引的工作方式](http://www.agilesharp.com/showtopic-252.aspx) ,下面我摘抄他文章中的一个图片来让在线索引操作的步骤更加清晰。

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2012-10-25-sql-server-30-day8/sql-server-30-day8-201210251041214158.gif)](http://images.cnblogs.com/cnblogs_com/CareySon/201210/2012102510411794.gif)
