---
layout: post
title: "SQL查询入门(中篇)"
date: 2010-04-13
categories: blog
tags: [博客园迁移]
---

## ****

## **引言**

在前篇文章中[\(SQL查询入门（上篇\)](http://www.cnblogs.com/CareySon/archive/2010/04/05/1704928.html),我对数据库查询的基本概念以及单表查询做了详细的解释，本篇文章中，主要说明SQL中的各种连接以及使用范围，以及更进一步的解释关系代数法和关系演算法对在同一条查询的不同思路。

### **多表连接简介**

在关系数据库中，一个查询往往会涉及多个表，因为很少有数据库只有一个表，而如果大多查询只涉及到一个表的，那么那个表也往往低于第三范式，存在大量冗余和异常。

因此，连接\(Join\)就是一种把多个表连接成一个表的重要手段.

比如简单两个表连接学生表\(Student\)和班级\(Class\)表，如图:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-1_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/1_2.png)[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-2_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/2_2.png)

进行连接后如图：

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-3_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/3_2.png)

### **笛卡尔积**

笛卡尔积在SQL中的实现方式既是**交叉连接\(Cross Join\)** 。所有连接方式都会先生成临时笛卡尔积表，笛卡尔积是关系代数里的一个概念，表示两个表中的每一**行** 数据任意组合,上图中两个表连接即为笛卡尔积\(交叉连接\)

在实际应用中，笛卡尔积本身大多没有什么实际用处，只有在两个表连接时加上限制条件，才会有实际意义，下面看**内连接**

****

### **内连接**

如果分步骤理解的话，内连接可以看做先对两个表进行了交叉连接后，再通过加上限制条件\(SQL中通过关键字on\)剔除不符合条件的**行的子集** ,得到的结果就是内连接了.上面的图中，如果我加上限制条件

对于开篇中的两个表，假使查询语句如下：
    
    
    [SELECT](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=SELECT&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) *
      [FROM](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=FROM&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [Class] c
           [inner](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=inner&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [join](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=join&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) 
           [Student] s
           [on](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=on&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) c.ClassID=s.StudentClassID

可以将上面查询语句进行分部理解，首先先将Class表和Student表进行**交叉连接,生成** 如下表:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-5_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/5_2.png)

然后通过on后面的限制条件，只选择那些StudentClassID和ClassID相等的**列** （上图中划了绿色的部分）,最终，得到选择后的**表的子集**

****

**[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-4_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/4_2.png) **

****

**** 当然，**内连接** on后面的限制条件不仅仅是等号**，** 还可以使用**比较运算符** ,包括了>（大于）、>=（大于或等于）、<=（小于或等于）、<（小于）、\!>（不大于）、\!<（不小于）和<>（不等于）。当然，限制条件所涉及的两个列的**数据类型** 必须匹配.

对于上面的查询语句，如果将on后面限制条件由等于改为大于:
    
    
    [SELECT](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=SELECT&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) *
      [FROM](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=FROM&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [Class] c
           [inner](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=inner&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [join](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=join&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) 
           [Student] s
           [on](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=on&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) c.ClassID>s.StudentClassID

则结果从第一步的笛卡尔积中筛选出那些ClassID大于StudentClassID的**子集** :

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-6_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/6_2.png)

虽然上面连接后的表并没有什么实际意义，但这里仅仅作为DEMO使用:-\)

#### **关系演算**

上面笛卡尔积的概念是关系代数中的概念，而我在前一篇文章中提到还有关系演算的查询方法.上面的关系代数是分布理解的，上面的语句推导过程是这样的：“对表Student和Class进行内连接，匹配所有ClassID和StudentClassID相等行，选择所有的列”

而**关系演算法** ，更多关注的是**我想要什么** ,比如说上面同样查询，用关系演算法思考的方式是“给我找到所有学生的信息，包括他们的班级信息，班级ID，学生ID，学生姓名”

用关系演算法的SQL查询语句如下：
    
    
    [SELECT](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=SELECT&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) *
      [FROM](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=FROM&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [Class] c
           ,
           [Student] s
      [where](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=where&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) c.ClassID=s.StudentClassID

****

**** 当然，查询后返回的结果是不会变的：

****

**[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-4_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/4_2.png) **

### **外连接**

假设还是上面两个表，学生和班级.我在学生中添加一个名为Eric的学生，但出于某种原因忘了填写它的班级ID：

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-7_thumb_1.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/7_4.png) [![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-2_thumb_1.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/2_4.png)

当我想执行这样一条查询：给我取得所有学生的姓名和他们所属的班级:
    
    
    [SELECT](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=SELECT&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) s.StudentName,c.ClassName 
            
      [FROM](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=FROM&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [fordemo].[dbo].[Student] s
           [inner](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=inner&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [join](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=join&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) 
           [fordemo].[dbo].[Class] c
           [on](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=on&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) 
           s.StudentClassID=c.ClassID

结果如下图:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-8_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/8_2.png)

可以看到，这个查询“丢失”了Eric..

这时就需要用到外连接，外连接可以使连接表的一方，或者双方不必遵守on后面的连接限制条件.这里把上面的查询语句中的inner join改为left outer join:
    
    
    [SELECT](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=SELECT&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) s.StudentName,c.ClassName 
            
      [FROM](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=FROM&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [fordemo].[dbo].[Student] s
           [left](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=left&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [outer](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=outer&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [join](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=join&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) 
           [fordemo].[dbo].[Class] c
           [on](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=on&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) 
           s.StudentClassID=c.ClassID

结果如下：

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-9_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/9_2.png)

Eric又重新出现.

#### **右外连接**

右外连接和左外连接的概念是相同的，只是顺序不同，对于上面查询语句，也可以改成:
    
    
    [SELECT](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=SELECT&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) s.StudentName,c.ClassName 
            
      [FROM](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=FROM&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [fordemo].[dbo].[Class] c
           [right](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=right&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [outer](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=outer&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [join](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=join&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) 
           [fordemo].[dbo].[Student] s
           [on](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=on&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) 
           s.StudentClassID=c.ClassID

效果和上面使用了左外连接的效果是一样的.

#### **全外连接**

全外连接是将左边和右边表每行都至少输出一次,用关键字”full outer join”进行连接，可以看作是左外连接和右外连接的结合.

### **自连接**

谈到自连接，让我们首先从一个表和一个问题开始：

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-10_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/10_2.png)

上面员工表\(Employee\)，因为经理也是员工的一种，所以将两种人放入一个表中，MangerID字段表示的是当前员工的直系经理的员工id.

现在，我的问题是，如何查找CareySon的经理的姓名?

可以看出，虽然数据存储在单张表中，但除了嵌套查询\(这个会在后续文章中讲到\)，只有自连接可以做到.正确自连接语句如下:
    
    
    [SELECT](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=SELECT&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) m.EmployeeName
      [FROM](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=FROM&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [fordemo].[dbo].[Employee] e
      [inner](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=inner&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [join](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=join&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [fordemo].[dbo].[Employee] m
      [on](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=on&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99)  e.ManagerID=m.id [and](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=and&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) e.EmployeeName='Careyson'

在详细解释自连接的概念之前，请再看一个更能说明自连接应用之处的例子:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-11_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/11_2.png)

这个表是一个出席会议记录的表，每一行表示出席会议的记录\(这里，由于表简单，我就不用EmployeeID和MeetingID来表示了，用名称对于理解表更容易些\)

好了，现在我的问题是:找出既参加“谈论项目进度”会议，又参加”讨论职业发展”会议的员工

乍一看上去很让人迷惑是吧,也许你看到这一句脑中第一印象会是:
    
    
    [SELECT](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=SELECT&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99)  EmployeeName
      [FROM](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=FROM&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [fordemo].[dbo].[MeettingRecord] m
      [where](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=where&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) MeetingName='¨¬??????????¨¨' [and](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=and&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) meetingName='¨¬????¡ã¨°¦Ì¡¤¡é?1'

（我用的代码高亮插件不支持中文，所以上面where子句后面第一个字符串是’谈论项目进度’，第二个是’讨论职业发展’）

恩，恭喜你，答错了…如果这样写将会什么数据也得不到.正确的写法是使用自连接！

自连接的是一种特殊的连接，是对物理上相同但逻辑上不相同的表进行连接的方式。我看到百度百科上说自连接是一种特殊的内连接,但这是错误的,因为两个相同表之间不光可以内连接，还可以外连接，交叉连接…在进行自连接时，必须为其中至少一个表指定别名以对这两个表进行区分！

回到上面的例子，使用自连接，则正确的写法为:
    
    
    [SELECT](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=SELECT&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99)  m.EmployeeName
      [FROM](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=FROM&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [fordemo].[dbo].[MeettingRecord] m,
            [fordemo].[dbo].[MeettingRecord] m2
      [where](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=where&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) m.MeetingName='¨¬??????????¨¨' [and](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=and&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) m2.MeetingName='¨¬????¡ã¨°¦Ì¡¤¡é?1'
            [and](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=and&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) m.EmployeeName=m2.EmployeeName

（关于乱码问题，请参考上面\)

### **多表连接**

多个表连接实际上可以看成是对N个表进行n-1次双表连接.这样理解会让问题简单很多\!

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-1_thumb_1.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/1_4.png) [![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-2_thumb_2.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/2_6.png) [![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-12_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/12_2.png)

比如上面三个表，前两个表是我们已经在文章开始认识的，假设现在又添加了一个教师表，对这三个表进行笛卡尔积如下:
    
    
    [SELECT](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=SELECT&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) *
      [FROM](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=FROM&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [fordemo].[dbo].[Class]
           [cross](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=cross&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [join](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=join&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) 
           [fordemo].[dbo].[Teacher]
           [cross](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=cross&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) [join](http://search.microsoft.com/default.asp?so=RECCNT&siteid=us%2Fdev&p=1&nq=NEW&qu=join&IntlSearch=&boolean=PHRASE&ig=01&i=09&i=99) 
           [fordemo].[dbo].[Student]

### ****

结果可以如图表示:

[![image](https://cdn.jsdelivr.net/gh/careyson/careyson.github.io@main/assets/images/2010-04-13-sql/sql-13_thumb.png)](http://images.cnblogs.com/cnblogs_com/CareySon/WindowsLiveWriter/SQL_1121E/13_2.png)

### **总结**

文中对SQL中各种连接查询方式都做了简单的介绍，并利用一些Demo实际探讨各种连接的用处，掌握好各种连接的原理是写好SQL查询所必不可少的！
